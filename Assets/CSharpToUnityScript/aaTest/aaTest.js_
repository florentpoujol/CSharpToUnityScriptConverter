import UnityEngine;
import System.Collections;





// CLASSES DECLARATION
public class TestInheritance extends MonoBehaviour {}
public class TestInterface 
public class TestInterfaces implements 
public class TestInterfaces2 implements Int1, Int2 
public class aaTest extends MonoBehaviour implements  Int1 ,Int2 {

	// CONSTRUCTORS
	public function aaTest( aTruc: String) {
super(aTruc);
		// struff there 1
	}

	public function aaTest() {
super();
		// struff there 2
	}

	public function aaTest() {
aaTest();
		// struff there 3
	}

	public function aaTest( mahcin: String) 
	{
aaTest(aTruc);
		// struff there 4
	}


	// ATTRIBUTES
	@script HideInInspector
	@script RPC
	@script RequireComponent(Material)
	@script DrawGizmo(GizmoType.NotSelected | GizmoType.Pickable)
	@script AddComponentMenu("Transform/Follow Transform")
	@script ContextMenu("Do Something")
	@script MenuItem("MyMenu/Do Something")
	@script ExecuteInEditMode
	@script System.Serializable



	// VARIABLES

	// multiple variable declaration
	double aVar9= 3.5, aVar10, aVar11=5.0 ;
	string aVar1 = "un ; espace", aVar2;
	Class avar = new Class(), avar2 = new Class (untruc);
	

	// VAR DECLARATION WITHOUT VALUE
	private var avar: boolean;
	private static var avar: String;
	static private var avar: Dictionary.<String, boolean>;


	// VAR DECLARATION WITH VALUE
	public var var1: String = "mach ; in";
	public static var var3: String = @'machin'+	' machin chose'	;
	static public var var4: boolean = false;
	protected var var6: float[] = [3.5, 0];
	protected static var avar: double = Method (machin);
	static protected var var7: Class = new Class (parma, param);

	
	// VAR DECLARATION IN FOREACH LOOP
	for (var avar: String in avars)
	for (var avar: KeyValuePair.<String, boolean> in dico)

	// PATCHING garbage correction
	import System.Collections.Generics;

	private function Method(): String { return avar; }

	else
		avar = value;

	// CASTING
	string varCast1 = DoMachin();


	// ARRAYS
	string[] avar;
	string[] avar = new string[5];

	string[] avar = new string[] { "machin", "machin"};
	bool[] avar = [ false, true];

	float[] avar = new float[] { 0.0,
		3.5,
		5};
	int[] avar = new int[] { 0,
		3,
		5};



	// FUNCTIONS
	public function ReturnVoid() {
		string _var = ReturnString ( aBoolVar: ref)
	}

	private function ReturnString(ref bool testarg): String {}

	protected function ReturnBool( arg1: String, arg2: float): boolean {
		if (new Rect()) { // sould not be converted

		}
		else if (false) { // should not be converted

		}
	}

	public override function ToString(): string[] {
		return "ToString()";
	}

	private function ACoroutine( isTrue: boolean): IEnumerator {
		if (isTrue) {
			yield return null;
		}
		else {
			yield return new WaitForSeconds (3.5);
			// yield WaitForSeconds (3.5);
		}
		
	}



	// PROPERTIES
	private var prop1: int = 5;
	public function get Prop1(): int {
	return prop1;
}
public function set Prop1(value: int) {
	prop1 = value;
}


	private var prop2: int;
	public function get Prop2(): int { return prop2*2; 
		}


	private var prop3: String;
	public function set Prop3(value: String) { 
			prop3 = value+" ";
		}


	private var prop4: double;
	public function get Prop4(): double { return prop4; }
protected function set Prop4(value: double) {
			aVar9 = aVar10 + value;
		}



	// Use this for initialization
	private function Start() {
		
		string aVar1, aVar2;

		int aVar5, aVar6 , aVar7 ,aVar8;

		bool aVar3=true , aVar4;

		
	}


}

private class AStruct extends System.ValueType {
	gbase.machin
	super.machin
}