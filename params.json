{"body":"#What does it do ?\r\n\r\nThis extension for Unity3D does a damn good at converting C# scripts into UnityScript scripts.\r\nMore precisely, the extension provides a very good quality mass-conversion solution to translate C# code into UnityScript.\r\n\r\nCurrent version : 1.0\r\nLast edit of this manual on the 30th of November 2012.\r\n\r\n#Contact\r\n\r\nflorent dot poujol at gmail dot com\r\nhttp://www.florent-poujol.fr/en\r\nMy profile on Unity's forums : http://forum.unity3d.com/members/23148-Lion\r\n\r\n#How to buy\r\n\r\nYou will be able to buy this extension from the offical Unity Asset Store and from GamePrefabs.com at some point during the first week of December 2012.\r\n\r\nYou want to try before bying ? No problem !\r\nHead over to my website to [test the live demo](http://www.florent-poujol.fr/en/unity3d/c-to-unityscript-converter).\r\nUnlike the extension, you can convert only 100 lives at a time but the quality of the conversion is identical !\r\n\r\n#How to install\r\n\r\nExtract the CSharpToUnityScriptConverter.unitypackage in your Asset folder.\r\nIt will have created the \"Assets/CSharpToUnityScript\" folder.\r\n\r\nOpen the extension via the menu \"Script Converters > C# To UnityScript\".\r\n\r\n#How to use\r\n\r\nThe extension will convert any C# scripts found in the \"source\" directory and create their UnityScript conterpart in the \"target\" directory.\r\n\r\nBy default, the source directory is \"Assets/CSharpToUnityScript/Source\" and the target directory will be \"Assets/CSharpToUnityScript/ConvertedScripts\". You may change these paths via the appropriate fields.\r\n\r\nPut the C# scripts in your source directory then hit the \"convert\" button.\r\nThe extension tab shows you how many files are left to be converted.\r\nThe console display the name of the files when their conversion is completed.\r\n\r\nIf you have many files being converted and want to abord the conversion, just hit the \"Abord\" button.\r\nThis won't stops the conversion of the current file but it won't convert any more file after that.\r\nIf you hit the convert button again, it will convert again the whole source directory.\r\n\r\nThe conversion speed is about 10Ko or a couple hundreds of lines per second.\r\n\r\n#Options\r\n\r\nYou may choose if you want the converter to try to convert multiple inline variable declarations.\r\n\t// stuffs like :\r\n\tint var1, var2 = 2, var3, var4;\r\n\r\nDespite all my efforts, the converter may still match a few false positive.\r\nIf you are confident that the code you want to convert does not contains such declarations, or only a few of them, you better leave the box unticked.\r\n\r\n#Quality of the conversion\r\n\r\nBe advised that UnityScript has less features than C#.\r\nThat means that in some case, there is just no way to express in UnityScript what the C# does.\r\n\r\nIn some other cases, you will need to refactor part of the UnityScript code (when it's not done by the converter itself) to make it do the same thing as the C# code.\r\n\r\nFinally, in some yet other cases, the conversion may not be performed, depending on the syntactic environnement.\r\n\r\n##Take note of\r\n\r\nCasts without parenthesis around the casted expression stops at the first non alphanumeric character.\r\n\r\nMultiple inline variable declaration will be messed up or won't be converted at all if a semi-colon is found anywhere whithin the whole delcaration, before the semi-colon that closes the expression.\r\nAlso having curly brackets and/or parenthesis inside values or instance may lead the expression not to be converted.\r\n\r\n#Features not supported by UnityScript\r\n\r\nThis sections shows which features does not work in UnityScript, and try to provide a work around when possible.\r\n\r\nIn some cases, the converter could deal with the situation itself, but it is just not (yet) implemented.\r\n\r\n##Features dealt with by the converter\r\n\r\n* abstract keyword : abstract classes/methods are converted into regular classes/methods.\r\n* virtual keyword : it is just removed\r\n* Probably some others\r\n\r\n##Features that could be deal with by the converter (but that curently aren't)\r\n\r\n* You ca'nt have a method parameter nammed \"get\".\r\n* You can't create assembly aliases (using Alias=Assembly;)\r\n\r\n##Hopeless features\r\n\r\nThe converter can not do anything about them, you have to deal with the situation yourself.\r\n\r\n* Enums does not accepts negative values.\r\n* Static properties can't access another static property (you get the same error as if the accessed property is non-static).\r\n\r\n\r\n###Params keyword\r\n\r\nThey are left, so they pop errors in the Unity console.\r\nThe solution is to remove the \"params\" keyword from the method declaration, then wrap the parameters in an array in the method call.\r\n\r\nC# :\r\n\r\n\tvoid Method( params int[] values ) {}\r\n\tMethod( 1, 2 );\r\n\tMethod( 1, 2, 3 );\r\n\r\n\tvoid Method( string firstParam, params int[] values ) {}\r\n\tMethod( \"\", 1, 2 );\r\n\tMethod( \"\", 1, 2, 3 );\r\n\r\nUnityScript :\r\n\r\n\tfunction Method( values: int[] ) {}\r\n\tMethod( [1, 2] );\r\n\tMethod( [1, 2, 3] );\r\n\r\n\tfunction Method( firestParam: String, values: int[] ) {}\r\n\tMethod( \"\", [1, 2] );\r\n\tMethod( \"\", [1, 2, 3] );\r\n\r\n\r\n##Delegates and Events\r\n\r\nThey does not exists in UnityScript but can be simulated to some extends.\r\n\r\nYou can't create custom-nammed delegate or callable types as in C# or Boo but you can express specific method signatures as Boo does :\r\n\r\nC# :\r\n\r\n\tdelegate string DelegateName(int arg);\r\n\tDelegateName variabmeName = MethodName;\r\n\r\nBoo :\r\n\r\n\tCallableName as callable(int) as string\r\n\tvariableName as CallableName = MethodName\r\n\r\nUnityScript :\r\n\r\n\t// \"Function\" is a global callable type, that match any signatures. You should be able to use it wherever you use a delegate in C#\r\n\t// But you can also be more specific :\r\n\r\n\tfunction(int): String\r\n\tfunction(String, boolean) // same as    function(String, boolean): void\r\n\tvar variableName: function(int): String = MethodName;\r\n\r\nYou also still have access to .Net's Action<> and Func<> generic delegates.\r\n\r\nThe converter convert every occurence of a delegate name to its US conterpart.\r\nie : Every occurence of \"DelegateName\" would be replaced by \"function(int)\"\r\n\r\n\r\nEvents does not exists, but they are just a specialized collection of method, something you can reproduce in UnityScript, while it require some code refactoring.\r\n\r\nC# :\r\n\r\n\tdelegate void FooBarSignature(int data);\r\n\t// the event that will store the methods\r\n\tevent FooBarSignature foobarMethods;\r\n\r\n\t[...]\r\n\r\n\t// a method to be called when the event is thrown\r\n\tvoid AMethod( int param ) {}\r\n\r\n\t// registering methods\r\n\tfoobarMethods += AMethod;\r\n\r\n\t// throwing an event\r\n\tfoobarMethods( 1 );\r\n\r\nUnityScript :\r\n\r\n\t// the event can be simulated by any kind of list\r\n\tvar foobarMethodsList: List.<function(int)> = new List.<function(int)>();\r\n\r\n\tfunction foorbarMethods( param: int ) {\r\n\t\tfor (var method: function(int) in foobarMethodsList)\r\n\t\t\tmethod( param );\r\n\t}\r\n\r\n\t[...]\r\n\r\n\t// a method to be called when the event is thrown\r\n\tfunction AMethod( param: int ) {}\r\n\r\n\t// registering methods, this is what you need to go over and change yourself\r\n\tfoobarMethodsList.Add( AMethod );\r\n\r\n\t// throwing an event\r\n\tfoorbarMethods( 1 );\r\n\r\n\r\nAs of v1.0, nothing is done by the converter, everything is left untouched in the code.\r\n\r\n###Arrays\r\nSingle dimentionnal arrays should convert just fine.\r\n\r\nThe syntax of a multidimensionnal array in C#, becomes a jagged array in US :\r\nC# :\r\n\t{ {0}, {1} } // is of type int[,]\r\nUS :\r\n\t[ [0], [1] ] // is of type int[][] (same case in Boo)\r\n\r\n\r\nHere is some examples of what works, what doesn't :\r\n\r\nJagged arrays :\r\n\t// syntax that does not work\r\n\tvar jaggedArray: int[][];\t\t\t=>\tdisplay the error UCE0001: ';' expected. Insert a semicolon at the end.\r\n\tvar jaggedArray = new int[1][2];  \t=>  display the error : IndexOutOfRangeException: Array index is out of range.\r\n\tvar jaggedArray = new int[2][1];\t=>\tjaggedArray is of type int ...\r\n\r\nCreating an empty two level jagged array is done like this :\r\n\tvar jaggedArray = array.<int[]>(10); // jaggedArray is of type int[][]  <=>  int[10][]\r\nThe declaration of variable with empty array setting is the only thing that is handled by the converter.\r\n\tType[][] variable = new Type[num][];\r\n\t// is converted into\r\n\tvar variable = array.<Type[]>(num);\r\n\r\nBut I don't know what is the equivalent of the expression \"Type[][]\" in UnityScript. So they are left in the code and pop errors.\r\nYou can also create a jagged array by setting its value right away :\r\n\tvar array = [ [0], [1] ]; // array is of type int[][]\r\n\t\t\r\n\t\t\r\nMultiDimentionnal arrays :\r\n\tvar array: int[,];\t\t\t\t\t// \tWorks\r\n\tvar array = new int[1,1]; \t\t\t//\tWorks\r\n\tvar array: int[,] = new int[1,1]; \t//\tWorks\r\n\r\nYou can also use Boo's syntax :\r\n\tvar array = matrix(int, 1, 1);\r\n\tvar array: int[,] = matrix(int, 1, 1);\r\n\r\nIt seems that you can't set the value of a multidimentionnal array while declaring it.\r\n  \r\n  \r\n###Out and Ref keywords\r\n\r\nIn UnityScript, you don't need these keywords when you call a C# method (ie : the 'hitInfo' parameter of Physics.Raycast()).\r\nBut there is no way in UnityScript to create such behavior in the method declaration.\r\nRemember that you can still use C# classes from UnityScript scripts if they (the C# scripts) are compiled first.\r\n\r\nThere are no easy way to pass a value type as reference in UnityScript but here is one hack : you can use an intermediary variable which contains the value.\r\n\r\nC# :\r\n\tvoid RefMethod(ref int arg)\r\n\t{\r\n\t\targ = 20;\r\n\t}\r\n\r\n\tvoid Start()\r\n\t{\r\n\t\tint refVar = 5;\r\n\r\n\t\tRefMethod(ref refVar);\r\n\r\n\t\tDebug.Log(refVar); // will display 20\r\n\t}\r\n\r\nUnityScript :\r\n\tvar ref = Array();\r\n\r\n\tfunction RefMethod()\r\n\t{\r\n\t\tref[\"refVar\"] = 20;\r\n\t}\r\n\r\n\tfunction Start()\r\n\t{\r\n\t\tvar refVar = 5;\r\n\r\n\t\tref[\"refvar\"] = refVar;\r\n\t\tRefMethod();\r\n\t\trefVar = ref[\"refvar\"];\r\n\r\n\t\tprint(refVar); // will print 20\r\n\t}\r\n\r\n\r\n#Improving the conversion\r\n\r\nSometimes, someting that convert just fine in most of the scripts will just not convert at all or be messed up in another script, for no apparent reason.\r\nIf that happens, please contact me (see section at the top) and give me your script if it's not top-secret.\r\n\r\nSuch behaviour is often du to a particular syntactic situation that makes the converter not recogize a pattern (or recogize when it shouldn't).\r\nBy gathering scripts where this happends, I may be able to find what triggers the situation.","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"An extension for the Unity3D engine","google":"UA-9211759-15","name":"C# to UnityScript converter"}